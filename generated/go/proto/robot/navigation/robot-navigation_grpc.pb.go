// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: proto/robot/navigation/robot-navigation.proto

package navigationv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RobotNavigationService_GetMap_FullMethodName                 = "/agricultural.robot.navigation.v1.RobotNavigationService/GetMap"
	RobotNavigationService_SetMap_FullMethodName                 = "/agricultural.robot.navigation.v1.RobotNavigationService/SetMap"
	RobotNavigationService_UpdateMap_FullMethodName              = "/agricultural.robot.navigation.v1.RobotNavigationService/UpdateMap"
	RobotNavigationService_ClearMap_FullMethodName               = "/agricultural.robot.navigation.v1.RobotNavigationService/ClearMap"
	RobotNavigationService_GetPosition_FullMethodName            = "/agricultural.robot.navigation.v1.RobotNavigationService/GetPosition"
	RobotNavigationService_SetPosition_FullMethodName            = "/agricultural.robot.navigation.v1.RobotNavigationService/SetPosition"
	RobotNavigationService_StreamPosition_FullMethodName         = "/agricultural.robot.navigation.v1.RobotNavigationService/StreamPosition"
	RobotNavigationService_SendVelocityCommand_FullMethodName    = "/agricultural.robot.navigation.v1.RobotNavigationService/SendVelocityCommand"
	RobotNavigationService_StreamVelocityCommands_FullMethodName = "/agricultural.robot.navigation.v1.RobotNavigationService/StreamVelocityCommands"
	RobotNavigationService_StopMovement_FullMethodName           = "/agricultural.robot.navigation.v1.RobotNavigationService/StopMovement"
	RobotNavigationService_SendGoal_FullMethodName               = "/agricultural.robot.navigation.v1.RobotNavigationService/SendGoal"
	RobotNavigationService_SendTrajectory_FullMethodName         = "/agricultural.robot.navigation.v1.RobotNavigationService/SendTrajectory"
	RobotNavigationService_CancelGoal_FullMethodName             = "/agricultural.robot.navigation.v1.RobotNavigationService/CancelGoal"
	RobotNavigationService_GetNavigationStatus_FullMethodName    = "/agricultural.robot.navigation.v1.RobotNavigationService/GetNavigationStatus"
	RobotNavigationService_StreamNavigationStatus_FullMethodName = "/agricultural.robot.navigation.v1.RobotNavigationService/StreamNavigationStatus"
	RobotNavigationService_GetCameraInfo_FullMethodName          = "/agricultural.robot.navigation.v1.RobotNavigationService/GetCameraInfo"
	RobotNavigationService_StreamVideo_FullMethodName            = "/agricultural.robot.navigation.v1.RobotNavigationService/StreamVideo"
	RobotNavigationService_ControlCamera_FullMethodName          = "/agricultural.robot.navigation.v1.RobotNavigationService/ControlCamera"
	RobotNavigationService_GetLocalizationStatus_FullMethodName  = "/agricultural.robot.navigation.v1.RobotNavigationService/GetLocalizationStatus"
	RobotNavigationService_InitializeLocalization_FullMethodName = "/agricultural.robot.navigation.v1.RobotNavigationService/InitializeLocalization"
	RobotNavigationService_ResetLocalization_FullMethodName      = "/agricultural.robot.navigation.v1.RobotNavigationService/ResetLocalization"
)

// RobotNavigationServiceClient is the client API for RobotNavigationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RobotNavigationServiceClient interface {
	// Map Management
	GetMap(ctx context.Context, in *GetMapRequest, opts ...grpc.CallOption) (*MapResponse, error)
	SetMap(ctx context.Context, in *SetMapRequest, opts ...grpc.CallOption) (*MapResponse, error)
	UpdateMap(ctx context.Context, in *UpdateMapRequest, opts ...grpc.CallOption) (*MapResponse, error)
	ClearMap(ctx context.Context, in *ClearMapRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Position Management
	GetPosition(ctx context.Context, in *GetPositionRequest, opts ...grpc.CallOption) (*PositionResponse, error)
	SetPosition(ctx context.Context, in *SetPositionRequest, opts ...grpc.CallOption) (*PositionResponse, error)
	StreamPosition(ctx context.Context, in *StreamPositionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PositionUpdate], error)
	// Manual Control (Joystick)
	SendVelocityCommand(ctx context.Context, in *VelocityCommand, opts ...grpc.CallOption) (*VelocityResponse, error)
	StreamVelocityCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VelocityCommand, VelocityResponse], error)
	StopMovement(ctx context.Context, in *StopMovementRequest, opts ...grpc.CallOption) (*VelocityResponse, error)
	// Autonomous Navigation
	SendGoal(ctx context.Context, in *NavigationGoal, opts ...grpc.CallOption) (*NavigationResponse, error)
	SendTrajectory(ctx context.Context, in *TrajectoryCommand, opts ...grpc.CallOption) (*NavigationResponse, error)
	CancelGoal(ctx context.Context, in *CancelGoalRequest, opts ...grpc.CallOption) (*NavigationResponse, error)
	GetNavigationStatus(ctx context.Context, in *GetNavigationStatusRequest, opts ...grpc.CallOption) (*NavigationStatusResponse, error)
	StreamNavigationStatus(ctx context.Context, in *StreamNavigationStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NavigationStatusUpdate], error)
	// Camera and Video Streaming
	GetCameraInfo(ctx context.Context, in *GetCameraInfoRequest, opts ...grpc.CallOption) (*CameraInfoResponse, error)
	StreamVideo(ctx context.Context, in *StreamVideoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VideoFrame], error)
	ControlCamera(ctx context.Context, in *CameraControlRequest, opts ...grpc.CallOption) (*CameraControlResponse, error)
	// Localization and SLAM
	GetLocalizationStatus(ctx context.Context, in *GetLocalizationStatusRequest, opts ...grpc.CallOption) (*LocalizationStatusResponse, error)
	InitializeLocalization(ctx context.Context, in *InitializeLocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error)
	ResetLocalization(ctx context.Context, in *ResetLocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error)
}

type robotNavigationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRobotNavigationServiceClient(cc grpc.ClientConnInterface) RobotNavigationServiceClient {
	return &robotNavigationServiceClient{cc}
}

func (c *robotNavigationServiceClient) GetMap(ctx context.Context, in *GetMapRequest, opts ...grpc.CallOption) (*MapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MapResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_GetMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) SetMap(ctx context.Context, in *SetMapRequest, opts ...grpc.CallOption) (*MapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MapResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_SetMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) UpdateMap(ctx context.Context, in *UpdateMapRequest, opts ...grpc.CallOption) (*MapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MapResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_UpdateMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) ClearMap(ctx context.Context, in *ClearMapRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RobotNavigationService_ClearMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) GetPosition(ctx context.Context, in *GetPositionRequest, opts ...grpc.CallOption) (*PositionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_GetPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) SetPosition(ctx context.Context, in *SetPositionRequest, opts ...grpc.CallOption) (*PositionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_SetPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) StreamPosition(ctx context.Context, in *StreamPositionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PositionUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RobotNavigationService_ServiceDesc.Streams[0], RobotNavigationService_StreamPosition_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPositionRequest, PositionUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamPositionClient = grpc.ServerStreamingClient[PositionUpdate]

func (c *robotNavigationServiceClient) SendVelocityCommand(ctx context.Context, in *VelocityCommand, opts ...grpc.CallOption) (*VelocityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VelocityResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_SendVelocityCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) StreamVelocityCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VelocityCommand, VelocityResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RobotNavigationService_ServiceDesc.Streams[1], RobotNavigationService_StreamVelocityCommands_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[VelocityCommand, VelocityResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamVelocityCommandsClient = grpc.BidiStreamingClient[VelocityCommand, VelocityResponse]

func (c *robotNavigationServiceClient) StopMovement(ctx context.Context, in *StopMovementRequest, opts ...grpc.CallOption) (*VelocityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VelocityResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_StopMovement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) SendGoal(ctx context.Context, in *NavigationGoal, opts ...grpc.CallOption) (*NavigationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NavigationResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_SendGoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) SendTrajectory(ctx context.Context, in *TrajectoryCommand, opts ...grpc.CallOption) (*NavigationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NavigationResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_SendTrajectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) CancelGoal(ctx context.Context, in *CancelGoalRequest, opts ...grpc.CallOption) (*NavigationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NavigationResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_CancelGoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) GetNavigationStatus(ctx context.Context, in *GetNavigationStatusRequest, opts ...grpc.CallOption) (*NavigationStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NavigationStatusResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_GetNavigationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) StreamNavigationStatus(ctx context.Context, in *StreamNavigationStatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NavigationStatusUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RobotNavigationService_ServiceDesc.Streams[2], RobotNavigationService_StreamNavigationStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamNavigationStatusRequest, NavigationStatusUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamNavigationStatusClient = grpc.ServerStreamingClient[NavigationStatusUpdate]

func (c *robotNavigationServiceClient) GetCameraInfo(ctx context.Context, in *GetCameraInfoRequest, opts ...grpc.CallOption) (*CameraInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CameraInfoResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_GetCameraInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) StreamVideo(ctx context.Context, in *StreamVideoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VideoFrame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RobotNavigationService_ServiceDesc.Streams[3], RobotNavigationService_StreamVideo_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamVideoRequest, VideoFrame]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamVideoClient = grpc.ServerStreamingClient[VideoFrame]

func (c *robotNavigationServiceClient) ControlCamera(ctx context.Context, in *CameraControlRequest, opts ...grpc.CallOption) (*CameraControlResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CameraControlResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_ControlCamera_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) GetLocalizationStatus(ctx context.Context, in *GetLocalizationStatusRequest, opts ...grpc.CallOption) (*LocalizationStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocalizationStatusResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_GetLocalizationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) InitializeLocalization(ctx context.Context, in *InitializeLocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocalizationResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_InitializeLocalization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotNavigationServiceClient) ResetLocalization(ctx context.Context, in *ResetLocalizationRequest, opts ...grpc.CallOption) (*LocalizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LocalizationResponse)
	err := c.cc.Invoke(ctx, RobotNavigationService_ResetLocalization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RobotNavigationServiceServer is the server API for RobotNavigationService service.
// All implementations must embed UnimplementedRobotNavigationServiceServer
// for forward compatibility.
type RobotNavigationServiceServer interface {
	// Map Management
	GetMap(context.Context, *GetMapRequest) (*MapResponse, error)
	SetMap(context.Context, *SetMapRequest) (*MapResponse, error)
	UpdateMap(context.Context, *UpdateMapRequest) (*MapResponse, error)
	ClearMap(context.Context, *ClearMapRequest) (*emptypb.Empty, error)
	// Position Management
	GetPosition(context.Context, *GetPositionRequest) (*PositionResponse, error)
	SetPosition(context.Context, *SetPositionRequest) (*PositionResponse, error)
	StreamPosition(*StreamPositionRequest, grpc.ServerStreamingServer[PositionUpdate]) error
	// Manual Control (Joystick)
	SendVelocityCommand(context.Context, *VelocityCommand) (*VelocityResponse, error)
	StreamVelocityCommands(grpc.BidiStreamingServer[VelocityCommand, VelocityResponse]) error
	StopMovement(context.Context, *StopMovementRequest) (*VelocityResponse, error)
	// Autonomous Navigation
	SendGoal(context.Context, *NavigationGoal) (*NavigationResponse, error)
	SendTrajectory(context.Context, *TrajectoryCommand) (*NavigationResponse, error)
	CancelGoal(context.Context, *CancelGoalRequest) (*NavigationResponse, error)
	GetNavigationStatus(context.Context, *GetNavigationStatusRequest) (*NavigationStatusResponse, error)
	StreamNavigationStatus(*StreamNavigationStatusRequest, grpc.ServerStreamingServer[NavigationStatusUpdate]) error
	// Camera and Video Streaming
	GetCameraInfo(context.Context, *GetCameraInfoRequest) (*CameraInfoResponse, error)
	StreamVideo(*StreamVideoRequest, grpc.ServerStreamingServer[VideoFrame]) error
	ControlCamera(context.Context, *CameraControlRequest) (*CameraControlResponse, error)
	// Localization and SLAM
	GetLocalizationStatus(context.Context, *GetLocalizationStatusRequest) (*LocalizationStatusResponse, error)
	InitializeLocalization(context.Context, *InitializeLocalizationRequest) (*LocalizationResponse, error)
	ResetLocalization(context.Context, *ResetLocalizationRequest) (*LocalizationResponse, error)
	mustEmbedUnimplementedRobotNavigationServiceServer()
}

// UnimplementedRobotNavigationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRobotNavigationServiceServer struct{}

func (UnimplementedRobotNavigationServiceServer) GetMap(context.Context, *GetMapRequest) (*MapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMap not implemented")
}
func (UnimplementedRobotNavigationServiceServer) SetMap(context.Context, *SetMapRequest) (*MapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMap not implemented")
}
func (UnimplementedRobotNavigationServiceServer) UpdateMap(context.Context, *UpdateMapRequest) (*MapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMap not implemented")
}
func (UnimplementedRobotNavigationServiceServer) ClearMap(context.Context, *ClearMapRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearMap not implemented")
}
func (UnimplementedRobotNavigationServiceServer) GetPosition(context.Context, *GetPositionRequest) (*PositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPosition not implemented")
}
func (UnimplementedRobotNavigationServiceServer) SetPosition(context.Context, *SetPositionRequest) (*PositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPosition not implemented")
}
func (UnimplementedRobotNavigationServiceServer) StreamPosition(*StreamPositionRequest, grpc.ServerStreamingServer[PositionUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method StreamPosition not implemented")
}
func (UnimplementedRobotNavigationServiceServer) SendVelocityCommand(context.Context, *VelocityCommand) (*VelocityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendVelocityCommand not implemented")
}
func (UnimplementedRobotNavigationServiceServer) StreamVelocityCommands(grpc.BidiStreamingServer[VelocityCommand, VelocityResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamVelocityCommands not implemented")
}
func (UnimplementedRobotNavigationServiceServer) StopMovement(context.Context, *StopMovementRequest) (*VelocityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopMovement not implemented")
}
func (UnimplementedRobotNavigationServiceServer) SendGoal(context.Context, *NavigationGoal) (*NavigationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendGoal not implemented")
}
func (UnimplementedRobotNavigationServiceServer) SendTrajectory(context.Context, *TrajectoryCommand) (*NavigationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTrajectory not implemented")
}
func (UnimplementedRobotNavigationServiceServer) CancelGoal(context.Context, *CancelGoalRequest) (*NavigationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelGoal not implemented")
}
func (UnimplementedRobotNavigationServiceServer) GetNavigationStatus(context.Context, *GetNavigationStatusRequest) (*NavigationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNavigationStatus not implemented")
}
func (UnimplementedRobotNavigationServiceServer) StreamNavigationStatus(*StreamNavigationStatusRequest, grpc.ServerStreamingServer[NavigationStatusUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method StreamNavigationStatus not implemented")
}
func (UnimplementedRobotNavigationServiceServer) GetCameraInfo(context.Context, *GetCameraInfoRequest) (*CameraInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCameraInfo not implemented")
}
func (UnimplementedRobotNavigationServiceServer) StreamVideo(*StreamVideoRequest, grpc.ServerStreamingServer[VideoFrame]) error {
	return status.Errorf(codes.Unimplemented, "method StreamVideo not implemented")
}
func (UnimplementedRobotNavigationServiceServer) ControlCamera(context.Context, *CameraControlRequest) (*CameraControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ControlCamera not implemented")
}
func (UnimplementedRobotNavigationServiceServer) GetLocalizationStatus(context.Context, *GetLocalizationStatusRequest) (*LocalizationStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocalizationStatus not implemented")
}
func (UnimplementedRobotNavigationServiceServer) InitializeLocalization(context.Context, *InitializeLocalizationRequest) (*LocalizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeLocalization not implemented")
}
func (UnimplementedRobotNavigationServiceServer) ResetLocalization(context.Context, *ResetLocalizationRequest) (*LocalizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetLocalization not implemented")
}
func (UnimplementedRobotNavigationServiceServer) mustEmbedUnimplementedRobotNavigationServiceServer() {
}
func (UnimplementedRobotNavigationServiceServer) testEmbeddedByValue() {}

// UnsafeRobotNavigationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RobotNavigationServiceServer will
// result in compilation errors.
type UnsafeRobotNavigationServiceServer interface {
	mustEmbedUnimplementedRobotNavigationServiceServer()
}

func RegisterRobotNavigationServiceServer(s grpc.ServiceRegistrar, srv RobotNavigationServiceServer) {
	// If the following call pancis, it indicates UnimplementedRobotNavigationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RobotNavigationService_ServiceDesc, srv)
}

func _RobotNavigationService_GetMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).GetMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_GetMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).GetMap(ctx, req.(*GetMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_SetMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).SetMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_SetMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).SetMap(ctx, req.(*SetMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_UpdateMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).UpdateMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_UpdateMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).UpdateMap(ctx, req.(*UpdateMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_ClearMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).ClearMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_ClearMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).ClearMap(ctx, req.(*ClearMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_GetPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).GetPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_GetPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).GetPosition(ctx, req.(*GetPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_SetPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).SetPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_SetPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).SetPosition(ctx, req.(*SetPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_StreamPosition_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPositionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotNavigationServiceServer).StreamPosition(m, &grpc.GenericServerStream[StreamPositionRequest, PositionUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamPositionServer = grpc.ServerStreamingServer[PositionUpdate]

func _RobotNavigationService_SendVelocityCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VelocityCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).SendVelocityCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_SendVelocityCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).SendVelocityCommand(ctx, req.(*VelocityCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_StreamVelocityCommands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RobotNavigationServiceServer).StreamVelocityCommands(&grpc.GenericServerStream[VelocityCommand, VelocityResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamVelocityCommandsServer = grpc.BidiStreamingServer[VelocityCommand, VelocityResponse]

func _RobotNavigationService_StopMovement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopMovementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).StopMovement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_StopMovement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).StopMovement(ctx, req.(*StopMovementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_SendGoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationGoal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).SendGoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_SendGoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).SendGoal(ctx, req.(*NavigationGoal))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_SendTrajectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrajectoryCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).SendTrajectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_SendTrajectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).SendTrajectory(ctx, req.(*TrajectoryCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_CancelGoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelGoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).CancelGoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_CancelGoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).CancelGoal(ctx, req.(*CancelGoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_GetNavigationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNavigationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).GetNavigationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_GetNavigationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).GetNavigationStatus(ctx, req.(*GetNavigationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_StreamNavigationStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamNavigationStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotNavigationServiceServer).StreamNavigationStatus(m, &grpc.GenericServerStream[StreamNavigationStatusRequest, NavigationStatusUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamNavigationStatusServer = grpc.ServerStreamingServer[NavigationStatusUpdate]

func _RobotNavigationService_GetCameraInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCameraInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).GetCameraInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_GetCameraInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).GetCameraInfo(ctx, req.(*GetCameraInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_StreamVideo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamVideoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotNavigationServiceServer).StreamVideo(m, &grpc.GenericServerStream[StreamVideoRequest, VideoFrame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RobotNavigationService_StreamVideoServer = grpc.ServerStreamingServer[VideoFrame]

func _RobotNavigationService_ControlCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CameraControlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).ControlCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_ControlCamera_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).ControlCamera(ctx, req.(*CameraControlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_GetLocalizationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocalizationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).GetLocalizationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_GetLocalizationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).GetLocalizationStatus(ctx, req.(*GetLocalizationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_InitializeLocalization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeLocalizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).InitializeLocalization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_InitializeLocalization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).InitializeLocalization(ctx, req.(*InitializeLocalizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotNavigationService_ResetLocalization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetLocalizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotNavigationServiceServer).ResetLocalization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RobotNavigationService_ResetLocalization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotNavigationServiceServer).ResetLocalization(ctx, req.(*ResetLocalizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RobotNavigationService_ServiceDesc is the grpc.ServiceDesc for RobotNavigationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RobotNavigationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "agricultural.robot.navigation.v1.RobotNavigationService",
	HandlerType: (*RobotNavigationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMap",
			Handler:    _RobotNavigationService_GetMap_Handler,
		},
		{
			MethodName: "SetMap",
			Handler:    _RobotNavigationService_SetMap_Handler,
		},
		{
			MethodName: "UpdateMap",
			Handler:    _RobotNavigationService_UpdateMap_Handler,
		},
		{
			MethodName: "ClearMap",
			Handler:    _RobotNavigationService_ClearMap_Handler,
		},
		{
			MethodName: "GetPosition",
			Handler:    _RobotNavigationService_GetPosition_Handler,
		},
		{
			MethodName: "SetPosition",
			Handler:    _RobotNavigationService_SetPosition_Handler,
		},
		{
			MethodName: "SendVelocityCommand",
			Handler:    _RobotNavigationService_SendVelocityCommand_Handler,
		},
		{
			MethodName: "StopMovement",
			Handler:    _RobotNavigationService_StopMovement_Handler,
		},
		{
			MethodName: "SendGoal",
			Handler:    _RobotNavigationService_SendGoal_Handler,
		},
		{
			MethodName: "SendTrajectory",
			Handler:    _RobotNavigationService_SendTrajectory_Handler,
		},
		{
			MethodName: "CancelGoal",
			Handler:    _RobotNavigationService_CancelGoal_Handler,
		},
		{
			MethodName: "GetNavigationStatus",
			Handler:    _RobotNavigationService_GetNavigationStatus_Handler,
		},
		{
			MethodName: "GetCameraInfo",
			Handler:    _RobotNavigationService_GetCameraInfo_Handler,
		},
		{
			MethodName: "ControlCamera",
			Handler:    _RobotNavigationService_ControlCamera_Handler,
		},
		{
			MethodName: "GetLocalizationStatus",
			Handler:    _RobotNavigationService_GetLocalizationStatus_Handler,
		},
		{
			MethodName: "InitializeLocalization",
			Handler:    _RobotNavigationService_InitializeLocalization_Handler,
		},
		{
			MethodName: "ResetLocalization",
			Handler:    _RobotNavigationService_ResetLocalization_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPosition",
			Handler:       _RobotNavigationService_StreamPosition_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamVelocityCommands",
			Handler:       _RobotNavigationService_StreamVelocityCommands_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamNavigationStatus",
			Handler:       _RobotNavigationService_StreamNavigationStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamVideo",
			Handler:       _RobotNavigationService_StreamVideo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/robot/navigation/robot-navigation.proto",
}
